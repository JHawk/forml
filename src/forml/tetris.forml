-- TETЯIS
-- ------

-- <link href='http://fonts.googleapis.com/css?family=Orbitron:500' rel='stylesheet' type='text/css'>
-- <script type="text/javascript">
-- $("header ul").prepend('<li><a id="play_tetris">Play<strong>Tetris</strong></a></li><li><a href="https://github.com/texodus/forml/blob/master/src/forml/tetris.forml">View On <strong>GitHub</strong></a></li>').css("width", "270");
-- $("#play_tetris").click(tetris.play);
-- </script>

-- <script id="game" type="text/html">
--    <div style='position:fixed;top:0;bottom:0;left:0;right:0;background-color:rgba(0,0,0,0.9)'>
--            <div id='container' style='position:relative;margin-left:auto;margin-right:auto;width:500px'>

--                <div style='position:absolute;right:0px;width:170px;top:20px;height:100px;font-family:Helvetica;color:white;font-size:1em'>SCORE</div>
--                <div id='score' style='position:absolute;right:0px;width:170px;top:40px;height:100px;font-family:Orbitron,Helvetica;color:white;font-weight:500;font-size:2em'></div>

--                <div style='position:absolute;right:0px;width:170px;top:100px;height:100px;font-family:Helvetica;color:white;font-size:1em'>LEVEL</div>
--                <div id='level' style='position:absolute;right:0px;width:170px;top:120px;height:100px;font-family:Orbitron,Helvetica;color:white;font-weight:500;font-size:2em'></div>

--                <div id='board' style='position:absolute;left:0px;top:20px;border: 3px solid;width:300px;height:600px;opacity:0.9'>
--                </div>
--            </div>
--     </div>
-- </script>


-- An implementation of the classic 80s computer game TETЯIS, written
-- in the programming language [Forml](http://texodus.github.com/forml).
-- [Tetris.forml](https://github.com/texodus/forml/blob/master/src/forml/tetris.forml) is an example of 
-- [literate programming](http://en.wikipedia.org/wiki/Literate_programming) - the source when compiled
-- generates this page.  You can run the test suite to see the [Jasmine](http://pivotal.github.com/jasmine) test report,
-- or just play Tetris.

-- Architecture
-- ------------
-- The entire application will live in the `tetris` module in the
-- global namespace.  We're going to need forml's standard library,
-- the `prelude`, as well as a number of sub modules:  the data
-- representation for the game will need additional functions from
-- `array` module, and the `html` module for manipulating the UI.

module tetris

    open prelude.string
    open prelude
    open prelude.html
    open prelude.array
    
    -- The order of import here is important - each `open` statement
    -- defines a new section, where subsequent `open`s shadow already
    -- imported symbols.  Because some symbols in `prelude.html` are shadowed by 
    -- those in `prelude.array`, we can bind the `prelude.html` to a record-
    -- typed symbol.  This allows us to access all the symbols from
    -- `prelude.html`, as well as use the `array` symbol as a function parameter.
    
    open prelude.html as html
    
    -- Some basic constants describing the physical laws of
    -- Tetris.
    
    n_rows    = 19
    n_columns = 9 

    -- The `Piece` type is a type synonym - it declares a local alias which
    -- can be used to make the type signatures easier to read.

    Piece = Array (Array Num)

    -- The classic Tetris pieces.
    
    pieces: Array Piece =
    
        let x = 0
            o = -1

        [ [ [ x ]
            [ x ]
            [ x ]
            [ x ] ]
    
          [ [ x, o ]
            [ x, o ]
            [ x, x ] ]
            
          [ [ o, x ]
            [ o, x ]
            [ x, x ] ]
    
          [ [ x, x ]
            [ x, x ] ]
            
          [ [ o, x, o ]
            [ x, x, x ] ]
            
          [ [ x, x, o ]
            [ o, x, x ] ]
            
          [ [ o, x, x ]
            [ x, x, o ] ] ]
            
    -- The valid piece colors.
            
    colors = [ [ "#0C3555", "#08789E", "#76F61E", "#F7D909", "#E11E6A" ]
               [ "#320010", "#74220F", "#B8A04E", "#E1D46C", "#80611D" ]
               [ "#542437", "#53777A", "#C02942", "#D95B43", "#53777A" ]  ]
    
    -- The game state.

    Board =

        { piece: Piece
          board: Array (Array Num)
          score: Num
          timer: Num
          level: Num

          x: Num
          y: Num }


        
    -- Main Loop
    -- ---------
    -- When the `Play Tetris` button is clicked, the action bound to
    -- the symbol `play` is realized:  the application's HTML UI is
    -- appended to the page, the game's state is initialized, and 
    -- handlers are configured for the game's keyboard events &
    -- timing loop.
    
    play = do
         
        game  <- game_template
        board <- new_board

        "body"   $+ game
        "#board" $| "background-color" <| (colors 'get (board.level - 1) 'get 0)
        "#board" $| "border-color"     <| (colors 'get (board.level - 1) 'get 1)
        "#score" $= to_commas board.score
        "#level" $= board.level
         
        ref <- tick board 'every 400
        board 'set_timer ref
        
        move board (-1) 0 'on_key 37
        rot  board        'on_key 38
        move board 1    0 'on_key 39
        move board 0    1 'on_key 40
        
    -- There are three pieces which currently require shelling out to
    -- Javascript.  `set_timer` is necessary because the prelude 
    -- currently lacks a library for implementing type safe mutations.
    -- `game_template` is an action which fetches the blank HTML
    -- for the board background from an embedded script template
    -- (see [source](https://github.com/texodus/forml/blob/master/src/forml/tetris.forml)) 
        
    set_timer ref board = `board.timer = ref` 
    game_template       = `jQuery("#game").html()`
    
    -- `to_commas` pretty prints the current score, using the the
    -- regex wrappers from the `prelude.string` module 
    
    to_commas: Num -> String | x =
    
        let r = "(\\d)(?=(\\d\\d\\d)+(?!\\d))"
        in  to_string x 'replace (regex r "g") "$1,"
         
    to_commas 1000 == "1,000"

    -- Heartbeat
    -- ---------

    tick board = do

        `board.y += 1`

        if is_valid board
            log "tick"
        else do
            `board.y = board.y - 1`
            new_piece board
            clear_lines board

        "#board" $= draw board

    with_board λ board =
    
        do! tick board
            yield (board.y == 1) 
                      && is_valid board
                      && board.score == 0
                      && board.level == 1
                      
    

    -- State
    -- -----
    -- `new_board` is a factory for generating a `Board` records
    -- representing a new game.
        
    new_board: JS Board = do

        let new_row = yield -1 'times (n_columns + 1)
        
        piece <- random_piece 0
        board <- sequence (new_row 'times (n_rows + 1))

        return {
            piece = piece
            board = board
            score = 0
            timer = 0
            level = 1

            x = 3
            y = 0
        }
     
    -- For the main game loop, we simply thread this gamestate through 
    -- each function which needs it.  This makes testing convenient:

    private   
    with_board f =
    
        do! board <- new_board
            yield f board
            
    -- which lets us write quick tests that are guaranteed a clean
    -- gamestate:
        
    with_board λ board = board.board 'length == n_rows + 1
    with_board λ board = board.board 'get 0 'length == n_columns + 1

    -- It would be helpful to have a function for quickly asserting 
    -- whether a point has a block.
    
    inline at x y b = b 'get y 'get x /= -1

    -- Notice that in checking whether a game state is valid, 
    -- `inline` predicates actually change the behavior of the 
    -- function.  If the predicates defined in the `let` block were
    -- not `inline`, as well as the `all?` function from the `prelude.array`
    -- module, `is_valid` would throw array-out-of-bounds exceptions
    -- on bounded-ness violating game states, since the predicates
    -- to `all?` (which is just `reduce (&&)`) would be evaluated
    -- non-lazily (since the `&&` operator is lazy, as in javascript).

    is_valid {board: board, piece: piece, x: x, y: y, _} =
    
        let by f n =
                0 .. (n - 1) |> map f |> all?

            inline intersect? =

                length piece 'by λ row =
                    length (piece 'get row) 'by λ col =

                        not (piece 'at col row
                          && board 'at (x + col) (y + row))

            inline x_bound? =
                x + length (get 0 piece) <= n_columns + 1

            inline y_bound? =
                y + length piece <= n_rows + 1

        all? [ x >= 0, x_bound?, y_bound?, intersect? ]

    -- Generate a random piece by selecting from `pieces`, then
    -- color it with a random color from the current palette.

    random_piece: Num -> JS Piece | level = do

        r <- rand (length pieces)
        c <- rand (length (get level colors) - 2)

        let piece = get r pieces

        yield piece 'map λ row =

            row 'map λ 0 = c
                     | _ = (-1)

    -- Rotate a piece 90 degrees.  Although this function is pure, internally
    -- it mutates arrays for construction, so we've just left its
    -- return type `JS Piece` to reflect these side-effects.
                
    rotate: Piece -> JS Piece | x =

        var new_row acc piece index col =

                if index < length piece
                
                    do acc <- put (get col (get index piece)) acc
                       new_row acc piece (index + 1) col

                else return do! reverse acc
        
        sequence <| map (new_row [] x 0) (0 .. length (get 0 x) - 1)

    get 3 pieces is
        do! rotate (get 3 pieces)
    
    get 1 pieces is
        do! rotate (get 1 pieces) >>= rotate >>= rotate >>= rotate
            
    get 4 pieces isnt
        do! rotate (get 4 pieces) >>= rotate



    
    -- Rendering
    -- ---------


    paint board x y color =

        `board.board[x][y] = color`

    css =
    
        "position: absolute;
         width: 26px;
         border: 3px solid rgba(0,0,0,0.4);
         border-right-width: 1px;
         border-top-width: 1px;
         border-radius: 3px;
         height: 26px;"

    inline
    block_string:

          Num -> Num -> String -> String
        | x      y      color   =

            "<div style='top:`y*30`px;left:`x*30`px;background-color:`color`;`css`'></div>"

    draw: Board -> String
    draw  { board: board, piece: piece, x: bx, y: by, level = level, _ } =

        var draw_block x y =
        
                if board 'at x y
                
                    let color = get ((get x (get y board)) + 2) (get (level - 1) colors)
                    block_string x y color

                else (if ((x - bx >= 0)
                            && (x - bx < length (piece 'get 0)) 
                            && (y - by >= 0)
                            && (y - by < length piece)
                            && piece 'at (x - bx) (y - by) )
                            
                          let color = colors 'get (level - 1) 'get ((piece 'get (y - by) 'get (x - bx)) + 2)
                          block_string x y color

                      else "")

            draw_row x = concat .: map (λf = f x) .: map draw_block
            rows       = 0 .. n_rows 'map λ_ = 0 .. n_columns

        in  concat <: zip_with draw_row (0 .. n_rows) rows 



    -- Player Events
    -- -------------

    every: Num -> JS _ -> JS Num
    every n action = `setInterval(action, n)`
    
    move: Board -> Num -> Num -> JS {} | board x y = do
    
        `board.x += x`
        `board.y += y`
        
        if is_valid board
            "#board" $= draw board
        else do
           `board.x = board.x - x`
           `board.y = board.y - y`
    
    rot board = do
        
        let old_piece = board.piece 
        rotated_piece <- rotate board.piece
        `board.piece = rotated_piece`
        if is_valid board
            "#board" $= draw board
        else `board.piece = old_piece`
    
    new_piece board = do

        board.piece 'for_each λ row =
            do! get row board.piece 'for_each λ col =
                    do! if board.piece 'at col row 
                            && (board.y + row <= n_rows + 1)
                            && (board.x + col <= n_columns + 1) then do

                            paint board (board.y + row) (board.x + col) (get col (get row board.piece)) 

                        else `undefined`
         
        new_piece <- random_piece (board.level - 1)    
        `board.piece = new_piece`
        `board.x = 3`
        `board.y = 0`
        
    clear_row board x = do

        `board.score += 100`
        "#score" $= to_commas board.score

        if board.score % 1000 == 0 then do
            `board.level += 1`
            "#level" $= board.level
            "#board" $| "background-color" <| (colors 'get (board.level - 1) 'get 0)
            "#board" $| "border-color"     <| (colors 'get (board.level - 1) 'get 1)
            log board.timer
            stop_timer board
            ref <- tick board 'every ((0.7 ^ board.level) * 400)
            board 'set_timer ref
        else `undefined`

        s <- reverse (1 .. x)

        yield s 'map λ row =
            do! get row board.board 'for_each λ col =
                do! paint board row col <| get col (get (row - 1) board.board)  
 
    stop_timer { timer = x, _ } = `clearInterval(x)`
        
    clear_lines board = do
    
        board.board 'for_each λ row =
            if reduce (&&) (map (λx = x != (-1)) (get row board.board))
                 do! clear_row board row
            else
                 do! `undefined`
                      

    
  
         
